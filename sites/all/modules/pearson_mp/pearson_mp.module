<?php
define('PEARSON_ROLES', serialize(array('Pearson Student', 'Pearson Professor', 'Pearson TA')));
// TODO: make a more error-proof require later
require_once 'sites/all/libraries/CryptLib/bootstrap.php'; // for doing encryption

function pearson_mp_views_api(){
	return array('api' => 2);
}

function example_page() {
  $data = array(
    array('fruit' => 'apple', 'votes' => 16),
    array('fruit' => 'mango', 'votes' => 10),
    array('fruit' => 'banana', 'votes' => 34),
    array('fruit' => 'peach', 'votes' => 20),
    array('fruit' => 'orange', 'votes' => 15),
  );
 
  $options_pie = array(
    'title' => 'Favourite fruits',
    'fields' => array(
      'votes' => array(
        'label' => t('Votes'),
        'enabled' => TRUE,
      ),
    ),
    'xAxis' => array(
      'labelField' => 'fruit',
    ),
    'data' => $data,
    'type' => 'pie',
  );
 
  $options_column = array(
    'title' => 'Favourite fruits',
    'fields' => array(
      'votes' => array(
        'label' => t('Votes'),
        'enabled' => TRUE,
      ),
    ),
    'xAxis' => array(
      'labelField' => 'fruit',
    ),
    'data' => $data,
    'type' => 'column',
  );
 
  $build['pie'] =  array(
    '#theme' => 'visualization',
    '#options' => $options_pie,
  );
 
  $build['column'] =  array(
    '#theme' => 'visualization',
    '#options' => $options_column,
  );
 
  return $build;
}

// hook_menu
function pearson_mp_menu(){
	$items = array();
  $items['example-charts'] = array(
    'title' => 'Example',
    'page callback' => 'example_page',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );	
	$items['mp/test'] = array(
		'type' => MENU_NORMAL_ITEM,		
		'title' => 'mp test',		
		'description' => 'test for ReST',		
		'page callback' => '_debug_mp',
		'page arguments' => array('hardcoded'),
		'access callback' => TRUE,
		'expanded' => TRUE,
  );
  $items['pearson-mp/ajaxgrade/%'] = array(
      'title' => 'Made for a button',
      'page callback' => '_ajax_grade',
      'page arguments' => array(2),
      'access callback' => TRUE,
      'type' => MENU_CALLBACK,
  );  
  
  $items['mp/test/prof'] = array(
    'title' => 'Prof form',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('_mpProf'),
    'access callback' => TRUE,
    'description' => 'we want to find details about this professor',
    'type' => MENU_NORMAL_ITEM,
  );
  
  $items['admin/settings/pearson_mp'] = array(
    'title' => 'Pearson Settings',
    'description' => 'Change/view Application ID, Client String, etc.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('_pearson_settings'),
    'access arguments' => array('administer pearson settings'),
    'type' => MENU_NORMAL_ITEM,
   );    
   
  $items['course-entry'] = array(
    'title' => 'Course Entry',
    'description' => 'Enter course',
    'page callback' => '_pearson_course_entry',
    'access arguments' => array('access content')
   );    
    
  return $items;
}

function _pearson_settings($form, &$form_state) {
  $form = array();

  $form['pearson_app_id'] = array(
    '#type' => 'textfield',
    '#title' => t('Pearson Application ID'),
    '#default_value' => variable_get('pearson_app_id'),
    '#description' => t("Used for all clients."),
    '#required' => TRUE,
  );
  $form['pearson_client_string'] = array(
    '#type' => 'textfield',
    '#title' => t('Pearson Client String'),
    '#default_value' => variable_get('pearson_client_string'),
    '#description' => t("Unique for Integration Campus."),
    '#required' => TRUE,
  );
  $form['pearson_term_id'] = array(
    '#type' => 'textfield',
    '#title' => t('Enter current Term ID'),
    '#default_value' => variable_get('pearson_term_id'),
    '#required' => TRUE,
  );
  $form['pearson_consumer_key'] = array(
    '#type' => 'textfield',
    '#title' => t('Enter Consumer Key (AKA: Token Key Moniker)'),
    '#default_value' => variable_get('pearson_consumer_key'),
    '#required' => TRUE,
  );
  $form['pearson_consumer_secret'] = array(
    '#type' => 'textfield',
    '#title' => t('Enter Consumer Secret (AKA: Shared Secret)'),
    '#default_value' => variable_get('pearson_consumer_secret'),
    '#required' => TRUE,
  );
  $form['pearson_principal'] = array(
    '#type' => 'textfield',
    '#title' => t('Principal'),
    '#default_value' => variable_get('pearson_principal'),
    '#required' => TRUE,
  );
  $form['pearson_principal_shared'] = array(
    '#type' => 'textfield',
    '#title' => t('Principal Shared Secret'),
    '#default_value' => variable_get('pearson_principal_shared'),
    '#required' => TRUE,
  );
  
  // begin adding links
  $defaultsLinks = variable_get('names_fieldset');
  $valsSet = FALSE;
  if (!empty($defaultsLinks)) $valsSet = TRUE;
  // dsm($defaultsLinks, 'default links');
  
  $form['#tree'] = TRUE;
  $form['names_fieldset'] = array(
    '#type' => 'fieldset',
    '#title' => t('Common links to access'),
    // Set up the wrapper so that AJAX will be able to replace the fieldset.
    '#prefix' => '<div id="names-fieldset-wrapper">',
    '#suffix' => '</div>',
  );

  // Build the fieldset with the proper number of names. We'll use
  // $form_state['num_names'] to determine the number of textfields to build.
  if (empty($form_state['num_names'])) {
    $form_state['num_names'] = 1;
	if ($valsSet) $form_state['num_names'] = count($defaultsLinks['pearson_link']);	  	
  }
  
	  
  for ($i = 0; $i < $form_state['num_names']; $i++) {
    $form['names_fieldset']['pearson_linkdesc'][$i] = array(
      '#type' => 'textfield',
      '#title' => t($i+1 . '. Description'),
      '#default_value' => ($valsSet) ? $defaultsLinks['pearson_linkdesc'][$i] : '',
    );
    $form['names_fieldset']['pearson_link'][$i] = array(
      '#type' => 'textfield',
      '#title' => t($i+1 . '. Link'),
	  '#default_value' => ($valsSet) ? $defaultsLinks['pearson_link'][$i] : '',      
    );
  }
  $form['names_fieldset']['add_name'] = array(
    '#type' => 'submit',
    '#value' => t('Add'),
    '#submit' => array('pearson_mp_add_more_add_one'),
    // See the examples in ajax_example.module for more details on the
    // properties of #ajax.
    '#ajax' => array(
      'callback' => 'pearson_mp_add_more_callback',
      'wrapper' => 'names-fieldset-wrapper',
    ),
  );
  if ($form_state['num_names'] > 1) {
    $form['names_fieldset']['remove_name'] = array(
      '#type' => 'submit',
      '#value' => t('Remove'),
      '#submit' => array('pearson_mp_add_more_remove_one'),
      '#ajax' => array(
        'callback' => 'pearson_mp_add_more_callback',
        'wrapper' => 'names-fieldset-wrapper',
      ),
    );
  } 
  
  // TODO: add submit button to reset all bundles

  return system_settings_form($form);
}

function pearson_mp_add_more_callback($form, $form_state) {
  return $form['names_fieldset'];
}

function pearson_mp_add_more_add_one($form, &$form_state) {
  $form_state['num_names']++;
  $form_state['rebuild'] = TRUE;
}

function pearson_mp_add_more_remove_one($form, &$form_state) {
  if ($form_state['num_names'] > 1) {
    $form_state['num_names']--;
  }
  $form_state['rebuild'] = TRUE;
}

function _pearson_course_entry() {
	// get the UserID, CourseID
	$userID = $_GET['UserID'];
	$userName = $_GET['UserName'];
	$courseID = $_GET['CourseID'];
	
	// $body = '{"webEntry":{"userId":' . $userID . ',"courseId":' . $courseID . ',"exitUrl":"http:\/\/www.ecollege.com","logoutUrl":"http:\/\/code.educationalpartner.com","courseReturnUrl":"http:\/\/www.mikedotexe.com"}}';
	
	$body = array();
	$body['webEntry'] = array('userId' => (int) $userID, 'courseId' => (int) $courseID, 'exitUrl' => 'http://www.ecollege.com', 'logoutUrl' => 'http://code.educationalpartner.com', "courseReturnUrl" => "http://www.mikedotexe.com");
	$body = json_encode($body);	
	
	// dsm($body, 'body');
	
	$access = remoteOAuth2GETAssertion($userName);
	// dsm($access, 'access');
	$ceObj = remoteOAuth2POST($access->access_token, '/lsEntry/course', $body);
	// dsm($ceObj, 'course entry object');
	$url = $ceObj->lsEntry->entryUrl;
	
	drupal_goto($url);
	// return '<div>' . 'mike' . '</div><br /><div>' . 'here' . '</div>';
}

function pearson_mp_permission() {
  return array(
    'administer pearson settings' => array(
      'title' => t('Access and change Pearson settings'),
      'description' => t('Allow users to access the settings page, change Application ID, etc...'),
    ),
	'pearson see all students' => array(
	  'title' => t('Allowed to see other students in the system, basic information like email and classes'),
	  'description' => t('On by default')
    ),
	'pearson see all grades' => array(
	  'title' => t('Allowed to see other students\' grades'),
	  'description' => t('Perhaps for teachers and teaching assistants')
    )
	);
}
// hook cron
function pearson_mp_cron(){
	watchdog('pearson_mp', 'running cron');
    $queueCoursesFromTerm = DrupalQueue::get("pearsonCourseFromTerm");
    // $queueUsersInCourses = DrupalQueue::get("pearsonUserFromCourse");
	
	// get list of courses from the term_id
	$term = variable_get('pearson_term_id');
	if (empty($term)){
		drupal_set_message('Pearson settings must be entered here: ' . l('Visit Pearson Settings (required)', 'admin/settings/pearson_mp'));
		return;
	}	
	
	$remoteAll = remoteOAuth1('/terms/' . $term . '/courses');
	// check to see if the hash is the same, function returns TRUE if there is new stuff
	$remoteAllSer = serialize($remoteAll);
	$newCoursesInfo = newHashedInfo('coursesFromTerm', $term, $remoteAllSer);
	if ($newCoursesInfo) variable_set('pearson updateCourseInfo', TRUE); // if there's new stuff to add from courses. need to know final ID too, see below
	$finalCourseID = '';
	if (is_array($remoteAll->courses)){ // this helps block warnings
		foreach ($remoteAll->courses as $k => $v){
		  // dsm($k, 'k'); // $k->id, ->displayCourseCode, ... title, callNumbers (array), links (array of Objects->href, ->rel)
		  
		  // now that we know who to attach to a course, create/update course nodes
		  $queueCoursesFromTerm->createItem($v);
		  $finalCourseID = $v->id;
		}
		// set variable so we know when the last one is processed later, and can turn 'pearson updateCourseInfo' to FALSE
		variable_set('pearson updateCourseInfo FinalID', $finalCourseID);		
	}
	// watchdog('pearson_mp_debug', 'Calling checkC');
	checkAnnouncements();
}

/*
 * Check for announcements
 * @$IDarray is an array of Pearson Course ID's to check
 */
function checkAnnouncements($IDarray = array()){
	$queueAnnFromCourse = DrupalQueue::get("pearsonAnnouncementFromCourse");
	if (empty($IDarray)){
		// want to check all announcements from all courses
		// TODO: not sure if we need to get hash information below
		$query = db_select('node', 'n');
		$query->join('field_data_field_pearson_course_number', 'c', 'n.nid = c.entity_id');
		$query->leftjoin('pearson_mp_hashes', 'h', 'c.field_pearson_course_number_value = h.description');
		// $query->fields('c', array('field_pearson_course_number_value'))->fields('h', array('hash'))->condition('n.type', 'pearson_course')->condition('h.type', 'ann');
		$query->fields('c', array('field_pearson_course_number_value'))->fields('h', array('hash'))->condition('n.type', 'pearson_course');
		$result = $query->execute()->fetchAll();
		
		// $debug1 = serialize($result);
		// watchdog('pearson_mp_debug', 'serialized result in checkAnnoucnements ' . $debug1);
		// dsm($result, 'result');\		
		foreach ($result as $k => $v) {			
			$queueAnnFromCourse->createItem($v);
		}
	} else {
		// only check for announcements from a particular course
		watchdog('pearson_mp_debug', 'should not be here');
		foreach ($IDarray as $cid){
			$query = db_select('pearson_mp_hashes', 'h');
			$query->fields('h', array('hash'))->condition('h.description', $cid)->condition('h.type', 'ann');
			$result = $query->execute()->fetchAll();
			if (empty($result)){
				$result[0] = new stdClass();
				$result[0]->hash = NULL;
			} 
			$result[0]->field_pearson_course_number_value = $cid;
			// dsm($result[0], 'result');
			
			// add to queue			
			$queueAnnFromCourse->createItem($result[0]);
		}
	}
} 

/*
 * This handles the queue that looks to update/add announcements
 */

function PearsonAnnouncements($item){
	// watchdog('pearson_mp_debug', 'Entering PearsonAnnouncements');
	$cid = $item->field_pearson_course_number_value;
	if (empty($cid)) return;	
	
	// $annData = remoteOAuth1("/courses/$cid/announcements")
	
	// get professor's username
	$query = db_select('field_data_field_pearson_course_number', 'c');
	$query->join('field_data_field_pearson_course_users', 'u', 'c.entity_id = u.entity_id');
	$query->join('users', 'd', 'u.field_pearson_course_users_target_id = d.uid');
	$query->join('users_roles', 'ur', 'd.uid = ur.uid');
	$query->join('role', 'r', 'ur.rid = r.rid');
	$query->join('field_data_field_pearson_username', 'n', 'd.uid = n.entity_id');
	$query->fields('n', array('field_pearson_username_value'))->condition('r.name', 'Pearson Professor')->condition('c.field_pearson_course_number_value', $cid);
	$res = $query->execute()->fetchAll();
	
	if (empty($res)){
		watchdog('pearson_mp', '[PearsonAnnouncements] Could not find username for teacher in course ' . $cid, NULL, WATCHDOG_CRITICAL);
		// watchdog('pearson_mp_debug', '[PearsonAnnouncements] Could not find username for teacher in course ' . $cid, NULL, WATCHDOG_CRITICAL);
		return;
	}
	
	$uname = $res[0]->field_pearson_username_value;
	
	// now that we have the professor's username, we can use OAuth2 assertion to get  
	$accessInfo = remoteOAuth2GETAssertion($uname);
	$accessToken = $accessInfo->access_token;
	
	// get announcements for course
	$announcements = remoteOAuth2GET($accessToken, '/courses/' . $cid . '/announcements');
	// watchdog('pearson_mp', 'Announcements for Course ' . $cid . ' (' . count($announcements->announcements) . ' total)');
	foreach ($announcements->announcements as $ann){
		updateOrAddAnnouncement($ann, $cid);
	}
	
}

function updateOrAddAnnouncement($item, $cid){
	// watchdog('pearson_mp_debug', 'Entering updateOrAddAnnouncement');
	// see if we have a node with that Pearson ID (not Drupal nid, or Node ID)
	// if so, return the nid, if not, return blank
	$findAnnID = $item->id;
	$query = db_select('node', 'n');
	$query->join('field_data_field_pearson_ann_id', 'b', 'n.nid = b.entity_id');
	$query
	  ->fields('n', array('nid', 'vid'))
	  ->condition('n.type', 'pearson_announcement')
	  ->condition('b.field_pearson_ann_id_value', $findAnnID);
	$result = $query->execute()->fetchAll();
	
	// see what the hash is, if there's already that announcement
	// TODO: see if we can use the newHashedInfo() return values instead of what's done here
	$query2 = db_select('pearson_mp_hashes', 'h');
	$query2->fields('h', array('hash'))->condition('h.type', 'ann')->condition('h.description', $item->id);
	$hashRes = $query2->execute()->fetchAll();
	$storedHash = $hashRes[0]->hash;
	
	// compare to computed hash
	$serialItem = serialize($item);
	$computedHash = hash("crc32b", $serialItem);
	
	// if they're the same, bail
	if ($computedHash == $storedHash){
		// same, no need to compute anymore
		watchdog('pearson_mp', 'Announcement hash the same for Announcement ID ' . $findAnnID);
		return;		
	}	
	  		  			
	$newNode = (object) NULL;
	$newNode->type = 'pearson_announcement';
	$newNode->uid = 1;
	$newNode->changed = strtotime("now");
	$newNode->status = 1;
	$newNode->comment = 0;
	$newNode->promote = 0;
	$newNode->moderate = 0;
	$newNode->sticky = 0;
	$newNode->language = 'und';

	$newNode->field_pearson_ann_id[LANGUAGE_NONE][0]['value'] = $findAnnID;
	$newNode->field_pearson_ann_subject[LANGUAGE_NONE][0]['value'] = $item->subject;
	$newNode->field_pearson_ann_text[LANGUAGE_NONE][0]['value'] = $item->text;
	$newNode->field_pearson_ann_submitter[LANGUAGE_NONE][0]['value'] = $item->submitter;
	$newNode->field_pearson_ann_startdisplayda[LANGUAGE_NONE][0]['value'] = $item->startDisplayDate;
	$newNode->field_pearson_ann_enddisplaydate[LANGUAGE_NONE][0]['value'] = $item->endDisplayDate;
	$newNode->title = $item->subject; // TODO: somewhat redundant
		
	// if we are updating this node
	if (!empty($result)){
		// we're updating this node
		//dsm('not empty');
		$newNode->nid = $result[0]->nid;
		$newNode->vid = $result[0]->vid; // will throw notice without this line
		// $newNode->is_new = FALSE;
	} else {
		// we're creating this node
		$newNode->created = strtotime("now");	
		$newNode->is_new = TRUE;	
	}
	
	// get the Drupal nid of the course it needs to point to, be a child of
	$query = db_select('field_data_field_pearson_course_number', 'p');
	$query->join('node', 'n', 'n.nid = p.entity_id');
	$query->fields('n', array('nid'))->condition('p.field_pearson_course_number_value', $cid);
	$result = $query->execute()->fetchAll();
	$nid = $result[0]->nid;	
	
	$newNode->field_pearson_ann_course[LANGUAGE_NONE][0]['target_id'] = $nid; // add this to the entity reference for course
	$newNode->field_pearson_ann_course[LANGUAGE_NONE][0]['target_type'] = 'node'; // required	
	
	node_save($newNode);	
	
	// add hash
	_add_hash('ann', $findAnnID, $computedHash, $item);
}
  
/*
*	Add hash to custom table we set up in hook_schema in pearson_mp.install
 *  $type might be coursesFromTerm
 * 	$description is now being typically used as the unique drupal ID
 */
function newHashedInfo($type, $description, &$item){
	$serialItem = serialize($item);
	// $hash = hash("crc32b", $item);
	$hash = hash("crc32b", $serialItem);
	// check to see if hash is the same as that in the database
	$query = db_select('pearson_mp_hashes', 'p');
	$query->fields('p', array('hash'))->condition('p.description', $description)->condition('p.type', $type);
	$result = $query->execute()->fetch();
	// TODO: this logic could probably be reduced to if(empty($result) || $result->hash != $hash), but keep it for easy debugging
	if (empty($result)){
		// never added to db before, add it
		_add_hash($type, $description, $hash, $item);
		return TRUE;
	} else {
		// found a previous entry in db
		// see if hashes are the same
		if ($result->hash == $hash){
			// everything is the same as the last time we checked
			// watchdog('pearson_mp', 'Nothing has been updated for hash ' . $type . ' ' . $description);
			return FALSE;
		} else {
			// it's different, go ahead and update stuff
			// update the hash in the database, and tell calling function that there's new stuff (TRUE)
			watchdog('pearson_mp', 'Adding hash for ' . $type . ' ' . $description);
			_add_hash($type, $description, $hash, $item);
			return TRUE;
		}
	}
}
 
function _add_hash($type, $description, $hash, &$item){
	// TODO: make sure this key is supposed to be at description
	db_merge('pearson_mp_hashes')
	  ->key(array('description' => $description))
	  ->fields(array(
	  	  'type' => $type,
	      'hash' => $hash,
	      'fulldata' => serialize($item),
	  ))
	  ->execute();	
}

// tell drupal we have a queue to work on during cron
function pearson_mp_cron_queue_info() {
  $ret = array();
  $ret['pearsonCourseFromTerm'] = array(
    'worker callback' => 'PearsonUpdateOrAdd', //function to call for each item
    'time' => 600, //seconds to spend working on the queue
  );
  $ret['pearsonAnnouncementFromCourse'] = array(
    'worker callback' => 'PearsonAnnouncements', //function to call for each item
    'time' => 600, //seconds to spend working on the queue
  );
  // $ret['pearsonUserFromCourse'] = array(
    // 'worker callback' => 'PearsonUpdateOrAddUser', //function to call for each item
    // 'time' => 600, //seconds to spend working on the queue
  // );
  return $ret;
}

function remoteOAuth1($route, $ct_urlenc = FALSE){
	// Set up the variables necessary to make the Request 
	$method          = 'GET'; 
	$application_id  = variable_get('pearson_app_id');  //Your Application's ID/Key. Use for all campuses.
	$consumer_key    = variable_get('pearson_consumer_key');    //Campus-specific 
	$consumer_secret = variable_get('pearson_consumer_secret'); //Campus-specific  
	$nonce           = md5(microtime());   //Random & unique for every call
	$api_route       = $route;            //The API call you're requesting
	$post_body       = '{requestBody}';    //POST or PUT body
	$request_url     = 'https://api.learningstudio.com'.$api_route;  
	 
	 
	// Define OAuth Parameters
	$oAuthVariables = array(); 
	$oAuthVariables['application_id'] = $application_id; 
	$oAuthVariables['oauth_consumer_key'] = $consumer_key; 
	$oAuthVariables['oauth_nonce'] = $nonce; 
	$oAuthVariables['oauth_signature_method'] = 'CMAC-AES';
	$oAuthVariables['oauth_timestamp'] = time();
	 
	 
	// Create a Signable String
	// If this is a POST or PUT we tack on the body as a parameter 
	// *only* for the signable string. The body is base64 encoded, and then 
	// url-encoded TWICE. 
	$signable_string = $method.'&'.urlencode($api_route).'&'; 
	 
	$StringParts = $oAuthVariables; 
	if($method=='POST' || $method=='PUT')                               
		$StringParts['body'] = urlencode(urlencode(base64_encode($post_body))); 
	 
	ksort($StringParts); 
	 
	$encodable = array(); 
	 
	foreach($StringParts as $key=>$value){ 
		$encodable[] = $key.'='.$value; 
	} 
	 
	$signable_string.=urlencode(implode('&',$encodable)); 
	 
	 
	// Get a Signature for the string. Signature is an AES-CMAC hash.
	$CMACEngine = new CryptLib\MAC\Implementation\CMAC;
	// $CMACEngine = new CryptLib\\MAC\\Implementation\\CMAC;
	 
	$packed_string = ''; 
	$stringlength = strlen($signable_string); 
	for($i=0; $i<$stringlength; $i++) { 
	    $packed_string .= pack("c", ord(substr($signable_string, $i, 1))); 
	} 		
	//dsm($packed_string, 'packed string'); 
	$binary_cmac = $CMACEngine->generate($packed_string,$consumer_secret); 
	//dsm($binary_cmac, 'binary cmac');
	
	$signature = base64_encode($binary_cmac);
	//dsm($signature, 'siggy');
	//return; 
	 
	// Create the OAuth HTTP Header 
	$header_vars = array('realm'=>$request_url); 
	$header_vars = array_merge($header_vars,$oAuthVariables); 
	$header_vars['oauth_signature'] = $signature; 
	 
	$header_parts = array(); 
	foreach($header_vars as $k=>$v){ 
		$v = ($k=='realm')?$v:urlencode($v); 
		$header_parts[] = $k.'="'.$v.'"'; 
	} 
	 	
	$oauth_http_header = "X-Authorization: OAuth ".implode(',',$header_parts);
	 	 
	// Use cURL to make the request 
	$ch = curl_init();
	curl_setopt($ch, CURLOPT_URL, $request_url);
	curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
	curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); // used to be 0 and worked
	curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Windows; U; MSIE 9.0; WIndows NT 9.0; en-US)'); 
	curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $method);
	if ($ct_urlenc){
		// add "Content-Type: application/x-www-form-urlencoded" to header as well
		curl_setopt($ch, CURLOPT_HTTPHEADER, array('Content-Type: application/x-www-form-urlencoded', $oauth_http_header));
	} else {
		curl_setopt($ch, CURLOPT_HTTPHEADER, array($oauth_http_header));
	}
	 
	if($method=='POST' || $method=='PUT')
		curl_setopt($ch, CURLOPT_POSTFIELDS, $post_body);
	 	 
	// Execute & get variables
	$api_response = curl_exec($ch);
	$curlError = curl_error($ch);
	$info = curl_getinfo($ch); 
	$http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);
	 
	// Test if there was a cURL problem (request didn't go through)
	if($curlError){
	 	 watchdog('pearson_mp', $curlError . " - There was a problem making the API Call. cURL problem", NULL, WATCHDOG_CRITICAL);
		 //dsm($curlError, "There was a problem making the API Call. cURL problem"); 
	 
	// Test if there is a 4XX error (request went through but erred). 
	} else if(intval($http_code / 100) >=4){
	 
		$decoded = json_decode($api_response); 
		$msg = (is_object($decoded) && isset($decoded->error->message))?$decoded->error->message:"No message reported.";
		$msg.= " Error ID: "; 
		$msg.= (is_object($decoded) && isset($decoded->error->errorId) && !empty($decoded->error->errorId))?$decoded->error->errorId:'None provided';  
	 	watchdog('pearson_mp', $msg . " - The API Server responded with ".$http_code.". Message was:".$info." route:". $route, NULL, WATCHDOG_CRITICAL);
		//dsm($msg, "The API Server responded with ".$http_code.". Message was:"); 
	 	return 'error, see log ' . $msg . " - The API Server responded with ".$http_code.". Message was:".$info." route:". $route;
	// Else you have a successful response. 
	} else {
		// return $api_response;
		$decoded_response = json_decode($api_response); 
		// dsm($decoded_response);
		return $decoded_response;		
	}	
}

// $item will be an individual course for the term
/* $item->id, 
		->displayCourseCode
 * 		->title
 * 		->callNumbers (array)
 * 		->links (array)
 * 			0->href
 * 			 ->rel
 */
function PearsonUpdateOrAdd($item){
	// This essentially has each item that looks like what is returned from 
	//dsm($item, 'item in the actual worker function');
	
	// see if we have a node with that Pearson ID (not Drupal nid, or Node ID)
	// if so, return the nid, if not, return blank
	$findCourseID = $item->id;
		
	$query = db_select('node', 'n');
	$query->join('field_data_field_pearson_course_number', 'b', 'n.nid = b.entity_id');
	$query
	  ->fields('n', array('nid', 'vid'))
	  ->condition('n.type', 'pearson_course')
	  ->condition('b.field_pearson_course_number_value', $findCourseID);
	$result = $query->execute()->fetchAll();
	
	//see if there is hash info
	$isNewInfo = newHashedInfo('course', $findCourseID, $item); // $item is NOT serialized, done so in function
	

	
	// if there's no new info - hash is same - then let's get out of here
	
	//TODO think i can remove the if block below
	// if ($findCourseID == '8930875'){
		// // debugging
		// $serialItem = serialize($item);
		// $computedHash = hash("crc32b", $serialItem);
		// watchdog('db', 'computed for mine is ' . $computedHash . ' - ' . $isNewInfo . 'end');		
		// // watchdog('db', 'this one');
	// }
	// this block structured this way becuase I recall trouble using || and negatives. can return to later, this will work
	if (!empty($result)){ // if that course already exists
		if ($isNewInfo == FALSE){ // and the hashes are the same
			return;
		}		
	}
	//TODO think i can remove the if block below
	// if ($findCourseID == '8930875'){
		// watchdog('db', 'made it past');
	// }
	// begin - add users	
	  // we'll be using this below to add users to a course
	  $item->entity_reference = array(); 
	  
	  // get the User Enrollment information on this course
	  $remoteUsersForCourse = remoteOAuth1('/courses/' . $findCourseID . '/enrolledUsers');
	  // loop through, adding to queue, and also adding person to parent foreach, so we can reference them in the course node later		  
	  if (is_array($remoteUsersForCourse->enrolledUsers)){
	  	foreach ($remoteUsersForCourse->enrolledUsers as $user) {
	  		//dsm($user, 'user');
	  		//dsm($user->user->firstName, 'fname');
			// $queueUsersInCourses->createItem($user);
			
			// attach Pearson UID to the course information				
			$item->entity_reference[] = $user;			
			
		}
	  }	
	// end - add users	  
	
	//dsm($result, 'result from trying to fetch course id ' . $findCourseID);
		
		  			
	$newNode = (object) NULL;
	$newNode->type = 'pearson_course';
	$newNode->uid = 1;
	$newNode->changed = strtotime("now");
	$newNode->status = 1;
	$newNode->comment = 0;
	$newNode->promote = 0;
	$newNode->moderate = 0;
	$newNode->sticky = 0;
	$newNode->language = 'und';

	$newNode->field_pearson_course_number[LANGUAGE_NONE][0]['value'] = $findCourseID;
	$newNode->field_pearson_course_code[LANGUAGE_NONE][0]['value'] = $item->displayCourseCode;
	$newNode->title = $item->title;
	
	// call numbers
	for ($i=0; $i < count($item->callNumbers); $i++) { 
		$newNode->field_pearson_call_numbers[LANGUAGE_NONE][$i]['value'] = $item->callNumbers[$i];	
	}
	// links
	for ($i=0; $i < count($item->links); $i++) { 
		$newNode->field_pearson_links[LANGUAGE_NONE][$i]['value'] = $item->links[$i]->href;
	}
	
	// TODO: add all the entity references stored in (i think) $item->entity_reference (array)
	$i = 0;
	foreach ($item->entity_reference as $user) {		
		$drupalUID = PearsonUpdateOrAddUser($user, $findCourseID); // returns the drupal UID
		$newNode->field_pearson_course_users[LANGUAGE_NONE][$i]['target_id'] = $drupalUID; // add this to the entity reference for course
		$newNode->field_pearson_course_users[LANGUAGE_NONE][$i]['target_type'] = 'user'; // required
		$i++; // iterate
	}
	
	// if we are updating this node (if the Course ID already exists in the system)
	if (!empty($result)){
		//TODO: this is where we update the course node, but need to check and make shashes
		// we're updating this node
		//dsm('not empty');
		
		$newNode->nid = $result[0]->nid;
		$newNode->vid = $result[0]->nid; // will throw notice without this line
		
		// $newNode->is_new = FALSE;
	} else {
		// we're creating this node
		$newNode->created = strtotime("now");	
		$newNode->is_new = TRUE;
		
	}	
	
	node_save($newNode);	
	
	// add/update hash
	$serialItem = serialize($item);
	// $computedHash = hash("crc32b", $item);
	$computedHash = hash("crc32b", $serialItem);
	_add_hash('course', $findCourseID, $computedHash, $item);	
	
	// if this is the last one to update according to the variable, set it back to false (see hook_cron for more info)
	if ($item->id == variable_get('pearson updateCourseInfo FinalID')){
		variable_set('pearson updateCourseInfo FinalID', '');		
		variable_set('pearson updateCourseInfo', FALSE);
		watchdog('pearson_mp', 'Updated final course');		
	}	
}

// returns UID of the newly created, or already existing user that's passed in as a parameter
function PearsonUpdateOrAddUser($item2, $courseID){
	// see if the user has a Drupal account
	// $debug1 = serialize($item2);
	// watchdog('pearson_mp', $debug1);
	$query = db_select('users', 'u');
	$query->join('field_data_field_pearson_user_id', 'p', 'u.uid = p.entity_id');
	$query
		->fields('u', array('uid'))
		->condition('p.field_pearson_user_id_value', $item2->id);
	$result = $query->execute()->fetchAll();
	
	// now we need to figure out the pearson userName for this person
	$userInfo = remoteOAuth1('/users/' . $item2->id);
	$userName = '';
	if (is_object($userInfo)){
		// grab the userName provided by Pearson
		$userName = $userInfo->users[0]->userName;
	}
	
	// find out which roles to apply
	// 823 => PROF
	// 430 => TAST
	// 916 => STUD
	// watchdog('pearson_mp', 'setting initial auth role');
	$role = array(DRUPAL_AUTHENTICATED_RID => 'authenticated user');
	switch ($item2->role->id) {
		case '823':
			// watchdog('pearson_mp', 'setting prof');
			$role[variable_get('Pearson Professor')] = 'Pearson Professor';
			break;
		case '430':
			// watchdog('pearson_mp', 'setting ta');
			$role[variable_get('Pearson TA')] = 'Pearson TA';
			break;
		case '916':
		// watchdog('pearson_mp', 'setting student');
			$role[variable_get('Pearson Student')] = 'Pearson Student';
			break;
	}

	
	
	if (empty($result)){
		// make sure the name does not conflict (name column in users table is key)
		$query2 = db_select('users', 'u');
		$query2->fields('u', array('name'))->condition('u.name', $item2->user->firstName . ' ' . $item2->user->lastName);
		$existingNames = $query2->execute()->fetchAll();
		$delta = '';
		if (!empty($existingNames)){
			$delta = count($existingNames) + 1;
		}
		
		// we create a new user using user_save API
			// TODO: add specific roles automatically
		  $password = user_password(8);		 
		  //set up the user fields
		  $fields = array(
		    'name' => $item2->user->firstName . ' ' . $item2->user->lastName . $delta,
		    'mail' => $item2->user->emailAddress,
		    'pass' => $password,
		    'status' => 1,
		    'init' => 'email address',
		    'roles' => $role,
		    'field_pearson_user_id' => array(LANGUAGE_NONE => array(0 => array('value' => $item2->id))),
		    'field_pearson_username' => array(LANGUAGE_NONE => array(0 => array('value' => $userName))),
		  ); 
		 
		  //the first parameter is left blank so a new user is created
		  watchdog('pearson_mp', 'Creating new user ' . $item2->user->firstName . ' ' . $item2->user->lastName . ' (' . $userName . ') for course ' . $courseID . ' delta is ' . $delta);
		  $account = user_save('', $fields);
		  return $account->uid;	// uid of the newly created user
	} else {
		// TODO: revisit this, where we can update values, doesn't seem that important right now
			// we can choose to update the user information
			// TODO: add check to see if they have a setting flagged (not yet on settings page)
					
		  // $account = user_load($result[0]->uid);
// 		
		  // $fields = array(
		    // 'name' => $item2->user->firstName . ' ' . $item2->user->lastName,
		    // 'roles' => $role,
		    // 'field_pearson_user_id' => array(LANGUAGE_NONE => array(0 => array('value' => $item2->id))),
		  // ); 
// 		 
		  // // updates the user
		  // watchdog('pearson_mp', 'Updating user ' . $item2->user->firstName . ' ' . $item2->user->lastName . ' for course ' . $courseID);
		  // user_save($account, $fields);				
		
		  return $result[0]->uid; // this is the uid of the existing user					
	}		
}


function pearson_mp_form_alter(&$form, &$form_state, $form_id){
	// dsm($form, 'form');
	// dsm($form_id, 'form_id');
} 

function pearson_mp_form_user_profile_form_alter(&$form, &$form_state){
	// dsm(_decryptFromUID(1));
	// the below used to do the encryption
	// $form['#validate'][] = '_profile_submit';
}

function _profile_submit(&$form, &$form_state){
	// dsm($form_state, 'fs');
	// kept commented out in case I want to use encryption later
	// $enc = encrypt($form_state['values']['field_pearson_prof_password'][LANGUAGE_NONE][0]['value']);
	// $form_state['values']['field_pearson_prof_password'][LANGUAGE_NONE][0]['value'] = bin2hex($enc);
}

/*
 * good idea of how to use encryption, although not needing it now
function _decryptFromUID($uid, $role){
	$query = db_select('users', 'u');
	$query->join('field_data_field_pearson_prof_password', 'f', 'u.uid = f.entity_id');
	$query->fields('f', array('field_pearson_prof_password_value'));
	$result = $query->execute()->fetchAll();
	$bin = hex2bin($result[0]->field_pearson_prof_password_value);
	$dec = decrypt($bin);
	return $dec;
}
 */

// code to create a course node programmatically
/* 

$newNode = (object) NULL;
$newNode->type = 'pearson_course';
$newNode->uid = 1;
$newNode->created = strtotime("now");
$newNode->changed = strtotime("now");
$newNode->status = 1;
$newNode->comment = 0;
$newNode->promote = 0;
$newNode->moderate = 0;
$newNode->sticky = 0;
$newNode->language = 'und';
$newNode->title = "test";
$newNode->field_pearson_course_number[LANGUAGE_NONE][0]['value'] = "this###";
node_save($newNode);
 
 */
//----------------------------------
/*
	$ret = array();
	// get list of professor id's that are tagged with "include me in cron"
	//		prof => id
	$query = db_select('node', 'n');
	$query->join('field_data_field_pearson_include_cron', 'b', 'n.nid = b.entity_id');
$query->leftJoin('field_data_field_pearson_prof_courses', 'c', 'n.nid = c.entity_id');
	$query
	  ->fields('n', array('nid', 'title'))
->fields('c', array('field_pearson_prof_courses_value'))
	  ->condition('n.type', 'pearson_prof')
	  ->condition('n.status', '1')
	->condition('b.field_pearson_include_cron_value', 1);
	$result = $query->execute()->fetchAll();
	foreach ($result as $key => $value) {
		$ret['prof'][] = $value->title;
	}
	dsm($result, 'result');		
	dsm($ret, 'return value');
 */
//---------------------------------------------------
// curl stuff

/*
 commented out because we'll use assertion, and we dont have the field_pearson_prof fields anymore
function remoteOAuth2Tokens($uid = NULL, $u = NULL, $p = NULL){

	// in this case we have the uid and the email of the professor
	// let's get the token based on his/her username and password
	$ret = array();
	// get list of professor id's that are tagged with "include me in cron"
	//		prof => id
	$query = db_select('users', 'u');
	$query->join('field_data_field_pearson_prof_username', 'n', 'u.uid = n.entity_id');
	$query->join('field_data_field_pearson_prof_password', 'p', 'u.uid = p.entity_id');
	$query
	  ->fields('n', array('field_pearson_prof_username_value'))
	  ->fields('p', array('field_pearson_prof_password_value'))
	  ->condition('u.uid', $uid);
	$result = $query->execute()->fetchAll();
	// returns a result like this for username: $result[0]->field_pearson_prof_username_value
	
	// if (isset($result[0]->field_pearson_prof_username_value) && isset($result[0]->field_pearson_prof_password_value)){
		// both of them are set, let's request that token from Pearson LearningStudio
		$application_id = variable_get('pearson_app_id'); // this must be set by the client, stored as a Drupal variable using variable_set() API call
		$client_string = variable_get('pearson_client_string');
		// if there are arguments for these sent in, then use them 
		$username = (isset($u)) ? $u : $result[0]->field_pearson_prof_username_value; 
		$password = isset($p) ? $p : $result[0]->field_pearson_prof_password_value;
		
		$post_request = 'grant_type=password'
						.'&client_id='.$application_id
			   			.'&username='.$client_string.'\\'.$username
			   			.'&password='.$password; 

		$ch = curl_init();
		curl_setopt($ch, CURLOPT_URL, 'https://m-api.ecollege.com/token');
		curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
		curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'POST');
		curl_setopt($ch, CURLOPT_POSTFIELDS, $post_request);
		 
		// TODO: remove below, only for competition sprint 
		curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0);
		 
		$api_response = curl_exec($ch); 		 
		$curlError = curl_error($ch);		 
		$http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);
		 
		if($curlError){
			watchdog('pearson_mp', $curlError . ' - cURL problem');			 		
			//dsm($curlError, "There was a problem making the API Call. cURL problem"); 		 
		} else if (intval($http_code / 100) >= 4){		 
			$decoded = json_decode($api_response); 
			$msg = (is_object($decoded) && isset($decoded->error->message)) ? $decoded->error->message : "No message"; 
			$msg .= " Error ID: "; 
			$msg .= (is_object($decoded) && isset($decoded->error->errorId) && !empty($decoded->error->errorId)) ? $decoded->error->errorId : 'None provided';  
			watchdog('pearson_mp', $http_code . " - The API Server responded with http_code");
			// dsm($http_code, "The API Server responded with http_code");
			// dsm($msg, "Message"); 		 
		} else {
			// all systems go, we soon have refresh_token, access_token, and expires_in		 
			$decoded_response = json_decode($api_response); 
			return $decoded_response;
			// $decoded_response->access_token is what's really useful here
			//$course_info = getCourseInformation($decoded_response->access_token);
		}			
	// }
}
*/

function remoteOAuth2POSTFile($access){
	// set up header
	$body = 
		'mikedotexe
		Content-Disposition: form-data; name=""; filename="purvis.txt"
		Content-Type: text/plain
		 
		this is the data. aloha.
		mikedotexe';

	$header = 'X-Authorization: Access_Token access_token=' . $access;
	$curl = curl_init();
	
	curl_setopt_array($curl, array(
	    CURLOPT_RETURNTRANSFER => 1,
	    CURLOPT_URL => 'https://api.learningstudio.com/tempfiles',
	    CURLOPT_POST => 1,
	    CURLOPT_POSTFIELDS => $body,
	    CURLOPT_HTTPHEADER => array($header, 'Content-Type: multipart/form-data; boundary=mikedotexe'),
	    CURLOPT_SSL_VERIFYPEER => 0
	));
		 	
	// Execute & get variables
	$api_response = curl_exec($curl);
	$curlError = curl_error($curl);
	$info = curl_getinfo($curl); 
	$http_code = curl_getinfo($curl, CURLINFO_HTTP_CODE);
	curl_close($curl);	
	 
	// Test if there was a cURL problem (request didn't go through)
	if($curlError){
	 	 watchdog('pearson_mp', $curlError . " - There was a problem making the API Call. cURL problem in remoteOAuth2POSTFile", NULL, WATCHDOG_CRITICAL);
	// Test if there is a 4XX error (request went through but erred). 
	} else if(intval($http_code / 100) >=4){
	 
		$decoded = json_decode($api_response); 
		$msg = (is_object($decoded) && isset($decoded->error->message))?$decoded->error->message:"No message reported.";
		$msg.= " Error ID: "; 
		$msg.= (is_object($decoded) && isset($decoded->error->errorId) && !empty($decoded->error->errorId))?$decoded->error->errorId:'None provided';  
	 	watchdog('pearson_mp', $msg . " - The API Server responded with ".$http_code.". Found in remoteOAuth2POSTFile", NULL, WATCHDOG_CRITICAL);
	// Else you have a successful response. 
	} else {	 
		$decoded_response = json_decode($api_response); 
		// dsm($decoded_response);  
		return $decoded_response;
	}
}

function remoteOAuth2GET($accessToken, $route, $decode = TRUE){
	// set up header
	$header = 'X-Authorization: Access_Token access_token=' . $accessToken;
	$curl = curl_init();
	
	curl_setopt_array($curl, array(
	    CURLOPT_RETURNTRANSFER => 1,
	    CURLOPT_URL => 'https://api.learningstudio.com' . $route,
	    CURLOPT_HTTPHEADER => array('Content-Type: application/x-www-form-urlencoded', $header),
	    CURLOPT_SSL_VERIFYPEER => 0
	));
		 	
	// Execute & get variables
	$api_response = curl_exec($curl);
	$curlError = curl_error($curl);
	$info = curl_getinfo($curl); 
	$http_code = curl_getinfo($curl, CURLINFO_HTTP_CODE);
	curl_close($curl);	
	 
	// Test if there was a cURL problem (request didn't go through)
	if($curlError){
	 	 watchdog('pearson_mp', $curlError . " - There was a problem making the API Call. cURL problem in remoteOAuth2GET . ", NULL, WATCHDOG_CRITICAL);
	// Test if there is a 4XX error (request went through but erred). 
	} else if(intval($http_code / 100) >=4){
	 
		$decoded = json_decode($api_response); 
		$msg = (is_object($decoded) && isset($decoded->error->message))?$decoded->error->message:"No message reported.";
		$msg.= " Error ID: "; 
		$msg.= (is_object($decoded) && isset($decoded->error->errorId) && !empty($decoded->error->errorId))?$decoded->error->errorId:'None provided';  
	 	watchdog('pearson_mp', $msg . " - The API Server responded with ".$http_code.". Found in remoteOAuth2GET", NULL, WATCHDOG_CRITICAL);
		return $msg . ' ' . $http_code;
	// Else you have a successful response. 
	} else {	 
		$decoded_response = json_decode($api_response); 
		// dsm($decoded_response);  
		if ($decode == TRUE)  
			return $decoded_response;
		else
			return $api_response;
	}
}

function remoteOAuth2POST($access, $route, $body){
	// set up header
	// watchdog('findthis', 'trying with body of ' . $body, NULL, WATCHDOG_CRITICAL);

	$header = 'X-Authorization: Access_Token access_token=' . $access;
	$curl = curl_init();
	
	curl_setopt_array($curl, array(
	    CURLOPT_RETURNTRANSFER => 1,
	    CURLOPT_URL => 'https://api.learningstudio.com' . $route,
	    CURLOPT_POST => 1,
	    CURLOPT_POSTFIELDS => $body,
	    CURLOPT_HTTPHEADER => array($header, 'Content-Type: application/json; charset=utf-8'),
	    CURLOPT_SSL_VERIFYPEER => 0
	));
		 	
	// Execute & get variables
	$api_response = curl_exec($curl);
	$curlError = curl_error($curl);
	$info = curl_getinfo($curl); 
	$http_code = curl_getinfo($curl, CURLINFO_HTTP_CODE);
	curl_close($curl);	
	 
	// Test if there was a cURL problem (request didn't go through)
	if($curlError){
	 	 watchdog('pearson_mp', $curlError . " - There was a problem making the API Call. cURL problem in remoteOAuth2POST", NULL, WATCHDOG_CRITICAL);
	// Test if there is a 4XX error (request went through but erred). 
	} else if(intval($http_code / 100) >=4){
	 
		$decoded = json_decode($api_response); 
		$msg = (is_object($decoded) && isset($decoded->error->message))?$decoded->error->message:"No message reported.";
		$msg.= " Error ID: "; 
		$msg.= (is_object($decoded) && isset($decoded->error->errorId) && !empty($decoded->error->errorId))?$decoded->error->errorId:'None provided';  
	 	watchdog('pearson_mp', $msg . " - The API Server responded with ".$http_code.". Found in remoteOAuth2POST", NULL, WATCHDOG_CRITICAL);
	// Else you have a successful response. 
	} else {	 
		$decoded_response = json_decode($api_response); 
		// dsm($decoded_response);  
		return $decoded_response;
	}
}

function remoteOAuth2GETAssertion($uname){
	// get username and decrypted password, then get token, then make request TODO: can get rid of this, but may want to use it later
	// $query = db_select('users', 'u');
	// $query->join('field_data_field_pearson_username', 'f', 'u.uid = f.entity_id');
	// $query->fields('f', array('field_pearson_username_value'))->condition('u.uid', $uid);
	// $result = $query->execute()->fetchAll();
// 	
	// if (empty($result)){
		// watchdog('pearson_mp', 'Could not find username for user with id ' . $uid, NULL, WATCHDOG_CRITICAL);
		// return;
	// }
		
	$eCMAC = new CryptLib\MAC\Implementation\ECollegeCMAC; 
  
	//Set up variables for creating the assertion
	$application_id   = variable_get('pearson_app_id');    //Your Application's ID/Key. Use for all campuses.
	$key_moniker      = variable_get('pearson_consumer_key');;  //Campus-specific 
	$secret_key       = variable_get('pearson_consumer_secret');     //Campus-specific
	$client_string    = variable_get('pearson_client_string');     //Campus-specific
	$application_name = $client_string;       //This data point isn't checked, so we go simple
	$username 	      = $uname; //$result[0]->field_pearson_username_value;         // User's username in LearningStudio
	$timestamp 	      = str_replace('+00:00','Z',gmdate('c')); //This format is important
	 
	 
	//Set up variables needed to make the request of the API 
	$api_url       = "https://api.learningstudio.com/token";
	$grantType 	   = "assertion";
	$assertionType = "urn:ecollege:names:moauth:1.0:assertion"; 
	 
	//Assemble the Assertion string following this pattern (see documentation for details)
	//$assertion = '{client_name}|{key_moniker}|{client_id}|{client_string}|{username}|{timestamp}';
	$assertion = "$application_name|$key_moniker|$application_id|$client_string|$username|$timestamp";
	 
	// Now get the CMAC hash of the assertion (the signature)
	try{
	 
		//Pass Assertion and Key to the generateEcollegeCMAC method. 
		//This assumes the Assertion string has NOT been binary encoded. This method will pack() the 
		//string for you, hash it, and then bin2hex it. 
		$cmac = $eCMAC->generateECollegeCMAC($assertion,$secret_key); 
	 
		//$cmac is now equal to something like 989d5631fc2a4cd831ba84e6c7d39478
	 
	} catch(Exception $e){ 
		exit($e->getMessage());  
	} 
	 
	//Append the signature hash to the Assertion 
	$assertion .= '|'.$cmac; 
	 
	//Set up the body of the POST request
	$post_fields = "grant_type=".$grantType."&assertion_type=".$assertionType."&assertion=".$assertion;  
	 
	//Set up cURL Transaction
	$ch = curl_init();
	curl_setopt($ch, CURLOPT_URL, $api_url);
	curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
	curl_setopt($ch, CURLOPT_CUSTOMREQUEST, "POST");
	curl_setopt($ch, CURLOPT_POSTFIELDS, $post_fields);
	curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); // used to be 0 and worked
	 
	//execute & get server response;
	$api_response = curl_exec($ch); 
	 
	//capture errors or other status codes
	$curl_error = curl_error($ch);
	$http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);
	 
	// Test if there was a cURL problem (request didn't go through)
	if($curl_error){	
		watchdog('pearson_mp', "There was a problem making the API Call. cURL problem: $curl_error", NULL, WATCHDOG_CRITICAL); 	 
	// Test if there is a 4XX error (request went through but erred). 
	} else if(intval($http_code / 100) >=4){	 
		$decoded_response = json_decode($api_response); 
		$msg = (is_object($decoded_response) && isset($decoded_response->error->message))?$decoded_response->error->message:"No message reported."; 
		watchdog('pearson_mp', "[remoteOAuth2GETAssertion] The API Server responded with ".$http_code.". Message was: $msg", NULL, WATCHDOG_CRITICAL);
	 
	// Else you have a successful response. 
	} else {
	 
		$decoded_response = json_decode($api_response); 
		$access_token = $decoded_response->access_token; 
		$expires_in = $decoded_response->expires_in; // seconds 
	 
		// echo "<b>Access Token:</b> $access_token<br /><br />"; 
		// echo "<b>Expires In:</b> $expires_in<br /><br />"; 
		return $decoded_response;	 
	}	
}


function _debug_mp($arg = NULL){
	return '<h1>here and also</h1> some ' . $arg . ' the end';
}

function _mpProf($form, &$form_state) {
  $prof_id = arg(3); //(empty(arg(3))) ? '' : arg(3);
  dsm($prof_id, 'prof_id');
  
  $form['description'] = array(
    '#type' => 'item',
    '#title' => t('Enter the Name and ID of a Professor'),
  );
  // This is the first form element. It's a textfield with a label, "Name"
  $form['name'] = array(
    '#type' => 'textfield',
    '#title' => t('Name'),
  );
  // _mpcurl(19, 'professor');
  _mpcurl();
  return $form;
}

function _mpcurl($id = NULL, $type = NULL){
	$apikey = get_api_key();
	dsm($apikey, 'API Key');
	
	if (isset($id)) dsm($id, 'id');	
	if (isset($type)) dsm($type, 'type');
	
	$curl_handle = curl_init();  
	curl_setopt_array($curl_handle, array(
		CURLOPT_URL => 'http://www.mikedotexe.com/index.php/app/plants',
	    CURLOPT_RETURNTRANSFER => 1,
	    CURLOPT_POST => 0,
	));

	
	// Optional, delete this line if your API is open  
	// curl_setopt($curl_handle, CURLOPT_USERPWD, $username . ':' . $password);  	
	
	$buffer = curl_exec($curl_handle);  
	curl_close($curl_handle);  
	  
	$result = json_decode($buffer);  
	dsm($result, 'result');
	return $result;
}

function _import_roles(){
	watchdog('pearson_mp', 'Import user roles...');
	$pearsonRoles = unserialize(PEARSON_ROLES);
	foreach ($pearsonRoles as $role) {
		$r = new stdClass();
		$r->name = $role;
		// if there's no role like this one yet
		if (!roleExists($role)) user_role_save($r);
		
		// let's store the role ID as a variable so we don't have to memorize or hack it
		$rid = setVarForRole($role);
		$r_perms = array('pearson see all students' => TRUE);
		// $r_perms = array();
		//$r_perms[] = array('pearson see all students' => TRUE); // everyone gets this by default
		if ($role == 'Pearson Professor') $r_perms = array_merge($r_perms, array('pearson see all grades' => TRUE)); // only professor gets this
		user_role_change_permissions($rid, $r_perms);  
	}	
}

// tied to _import_roles
function setVarForRole($name){
	$query = db_select('role', 'r');
	$query
		->fields('r', array('rid'))
		->condition('r.name', $name);
	$result = $query->execute()->fetchAll();
	// sets the variable	
	variable_set($name, $result[0]->rid);
	return $result[0]->rid;
	//dsm($result, 'res');		
}

// tied to _import_roles
function roleExists($name){
	$query = db_select('role', 'r');
	$query
		->fields('r', array('rid'))
		->condition('r.name', $name);
	$result = $query->execute()->fetchAll();
	// sets the variable	
	if (empty($result)) return false;
	return true;
}

/* called from .install 
 *TODO: unfinished 
 * */

function _import_bundles(){
	watchdog('pearson_mp', 'Import bundles...');
	$path = drupal_get_path('module', 'pearson_mp') . '/bundles';
	$dir = new DirectoryIterator($path);
	// dsm($path, 'dir');
	foreach ($dir as $fileinfo) {// loop through each file in the directory
		if (!$fileinfo->isDot()) { // make sure its not . (current directory) or .. (parent directory)
			$filename = $fileinfo->getFilename();
			$contents = file_get_contents($path . '/' . $filename);
			// dsm($filename, 'filename');
			// dsm($contents, 'c');
			
			if (function_exists('bundle_copy_import_submit')){ // function that bundle copy uses to import
				$form = array();
				$form_state = array();
				$form_state['values']['macro'] = $contents;
				// for these imports, work gets done in the _validate and _submit functions to do the actual import
				bundle_copy_import_submit('', $form_state); // function doesn't use first arg
				watchdog('pearson_mp', 'Imported ' . $filename);
			}else{
				$error = 'No bundle_copy_import_submit function found, bundle installation cannot proceed.';
				watchdog('pearson_mp', $error, NULL, WATCHDOG_CRITICAL);
				dsm($error);
			}	 			
		}
	}
}

/* called from .install 
 * Imports all rules defined in the /rules folder 
 * */

function _import_rules(){
	// basically I'll be mimicking functionality in the import function, check to make sure it exists, for good measure
	module_load_include('inc', 'rules', 'ui/ui.forms'); // otherwise it can't see the file
	
	watchdog('pearson_mp', 'Import rules...');
	$path = drupal_get_path('module', 'pearson_mp') . '/rules';
	$dir = new DirectoryIterator($path);
	// dsm($path, 'dir');
	foreach ($dir as $fileinfo) {// loop through each file in the directory
		if (!$fileinfo->isDot()) { // make sure its not . (current directory) or .. (parent directory)
			$filename = $fileinfo->getFilename();
			$contents = file_get_contents($path . '/' . $filename);
			// dsm($filename, 'filename');
			// dsm($contents, 'c');
			
			if (function_exists('rules_ui_import_form_validate')){ // function that bundle copy uses to import
				$form = array();
				$form_state = array();
				$form_state['values']['import'] = $contents;
				$form_state['values']['overwrite'] = 1;
				
				// for these imports, work gets done in the _validate and _submit functions to do the actual import
				rules_ui_import_form_validate($form, $form_state);
				rules_ui_import_form_submit($form, $form_state);
				watchdog('pearson_mp', 'Imported ' . $filename);
			}else{
				$error = 'No rules_ui_import_form_validate function found, rules installation cannot proceed.';
				watchdog('pearson_mp', $error, NULL, WATCHDOG_CRITICAL);
				// dsm($error);
			}	 			
		}
	}
}

function pearson_mp_user_view($account, $view_mode, $langcode){
	drupal_add_library('system', 'drupal.collapse');
	drupal_add_js('misc/form.js'); // don't know if its really required to collapsible fieldsets to work
	drupal_add_js('misc/collapse.js');	
	// dsm($account, 'account');
	$roles = $account->roles;
	unset($roles[2]);
	$printedRoles = implode(', ', $roles);
	$isStudent = FALSE;
	if (in_array('Pearson Student', $roles)) $isStudent = TRUE;
	// dsm(arg(1));
	
	$account->content['role'] = array(
	 '#type' => 'markup',
	 '#markup' => "<h3>Role(s): $printedRoles</h3>",
	);
	$links = array();
	$fromSettings = variable_get('names_fieldset');
	// dsm($fromSettings, 'fs');
	if (!empty($fromSettings)){
		// there are links to add
		for ($i=0; $i < count($fromSettings['pearson_linkdesc']); $i++) { 
			$links[] = l($fromSettings['pearson_linkdesc'][$i], $fromSettings['pearson_link'][$i], array('attributes' => array('target' => '_blank')));
		}
		$bred = implode('<br/>', $links);
		$account->content['common_links'] = array(
		 '#type' => 'markup',
		 '#markup' => "<h3>Common Link(s):</h3> $bred<hr/>",
		);
	}
	
	// $origAccount = $account->content;
	
	// add header
	$account->content['view'] = array(
	 '#type' => 'markup',
	 '#weight' => 99,
	 '#markup' => '<h1>Courses</h1>',
	);	
	
	// find all classes associated with this user, embed views for each
	$classIDs = classesByUID(arg(1));
	for ($i=0; $i < count($classIDs); $i++) {
		$view = views_embed_view('pearson_course', 'page', $classIDs[$i]->entity_id);
		$annView = views_embed_view('pearson_announcements', 'page', $classIDs[$i]->entity_id);
		// dsm($annView, '$annView');

		
		$classNode = node_load($classIDs[$i]->entity_id);
		// dsm($classNode, 'classNode');
		$pearsonCID = $classNode->field_pearson_course_number[LANGUAGE_NONE][0]['value'];
		$pearsonCC = $classNode->field_pearson_course_code[LANGUAGE_NONE][0]['value'];
		$pearsonUname = $account->field_pearson_username[LANGUAGE_NONE][0]['value'];
		$pearsonUID = $account->field_pearson_user_id[LANGUAGE_NONE][0]['value'];
		
		// $view .= l('Course Entry for ' . $pearsonCC, 'course-entry', array('query' => array('UserID' => $pearsonUID, 'UserName' => $pearsonUname, 'CourseID' => $pearsonCID), 'html' => TRUE, 'attributes' => array('target' => '_blank', 'class' => 'clearfix')));
		global $base_url;
		$img = '<img src="' . $base_url. '/sites/all/themes/danland/images/uhh/courseentry-wide.png" alt="Enter Course"/>';		
		$view .= l($img, 'course-entry', array('query' => array('UserID' => $pearsonUID, 'UserName' => $pearsonUname, 'CourseID' => $pearsonCID), 'html' => TRUE, 'attributes' => array('target' => '_blank', 'alt' => 'Enter Course', 'class' => array('courseentry'))));
		
		if (strpos($annView, 'view-content')){
			// we have results
			$view .= '<h3>Announcement(s)</h3>' . $annView;
		} else{
			$view .= '<h3>No Announcements</h3>';
		}

		// make fieldset to hold it
		$account->content['course' . $pearsonCID] = array(
			'#type'=>'fieldset',
			// '#title'=>'<h3>' . $classNode->title . '</h3>',
			'#title'=>$classNode->title,
			'#collapsible'=>true,
			'#collapsed'=>true,
			'#weight' => 100,
			  '#attributes' => array (
			    'class' => array(
			      'collapsible', 'collapsed'
			    )
			  )			
		);	
		
		// $account->content = drupal_render($account->content);
				
		$account->content['course' . $pearsonCID]['view' . $i] = array(
		 '#type' => 'markup',
		 '#weight' => 100 + $i * 5,
		 '#markup' => $view,
		);
		
		if ($isStudent){
			$together = $pearsonUID . '-' . $pearsonCID;
			ctools_include('ajax');
			// add button to check current grade
			$account->content['course' . $pearsonCID]['grade' . $together] = array(
			 '#type' => 'markup',
			 '#weight' => $account->content['course' . $pearsonCID]['view' . $i]['#weight'] + 2,
			 '#markup' => '<div id="pearsongrade' . $together . '" class="pearsongrade"></div>',
			);			
			$links = array();
			$links[] = ctools_ajax_text_button(t('What\'s my grade?'), "pearson-mp/ajaxgrade/1/" . $pearsonUID . '/' . $pearsonCID, t('Retrieve grade'));
			// dsm($links, 'links');
			$output = theme('item_list', array('items' => $links, 'title' => t('Current grade')));
			$account->content['course' . $pearsonCID]['gradebtn' . $together] = array(
			 '#type' => 'markup',
			 '#weight' => $account->content['course' . $pearsonCID]['view' . $i]['#weight'] + 1,
			 '#markup' => $output,
			);					
		}
		
		// make table
		// $table = array_diff($origAccount, $account->content);

	} 
	
		// $userID = $_GET['UserID'];
	// $userName = $_GET['UserName'];
	// $courseID = $_GET['CourseID'];
	

	
	// dsm($account, 'account');
	// dsm($view_mode, 'view mode');	
}

function _ajax_grade($js = NULL, $uid, $cid) {
  // dsm($js, 'js');
  // dsm($uid, 'uid');
  // dsm($cid, 'cid');
  // dsm($arg, 'arg');
  

	// $Average = array("Average", "data"); 
	// $Earned = array("Earned", "data"); 
	// $Possible = array("Possible", "data"); 
	// $XC = array("Extra Credit", "data"); 
	// $LC = array("Letter Grade", "data"); 
	// $Comments = array("Comments", "data");
	 
	// $row[] = "Data1";
	// $rows[] = $row;
	// $row[] = "Row Column 3 Data"; 
	// $row[] = "Row Column 4 Data";
// 	
	// $rows = array();
	// $rows[] = $row;
	
	// $account->content['course' . $pearsonCID]['debug'] = array(
	 // '#type' => 'markup',
	 // '#markup' => $html,
	// );	  
  
  $gradeObj = $a = remoteOAuth1("/users/$uid/courses/$cid/coursegradetodate");
  $items = array();
  if ($gradeObj->courseGradeToDate->shareWithStudent){
	$header = array();
	$rows = array();
	
	$header[] = array("data" => "Category");
	$header[] = array("data" => "Grade");
	
	$rows[] = array("Average", $gradeObj->courseGradeToDate->average); 
	$rows[] = array("Earned", $gradeObj->courseGradeToDate->earned); 
	$rows[] = array("Possible", $gradeObj->courseGradeToDate->possible); 
	$rows[] = array("Extra Credit", $gradeObj->courseGradeToDate->extraCredit); 
	$rows[] = array("Letter Grade", $gradeObj->courseGradeToDate->letterGrade->letterGrade); 
	$rows[] = array("Comments", $gradeObj->courseGradeToDate->letterGrade->comments);  	
	$html = theme('table', array('header' => $header, 'rows' => $rows));
	  // $items['Average'] = $gradeObj->courseGradeToDate->average;
	  // $items['Earned'] = $gradeObj->courseGradeToDate->earned;
	  // $items['Possible'] = $gradeObj->courseGradeToDate->possible;
	  // $items['Extra Credit'] = $gradeObj->courseGradeToDate->extraCredit;
	  // $items['Letter Grade'] = $gradeObj->courseGradeToDate->letterGrade->letterGrade;
	  // $items['Comments'] = $gradeObj->courseGradeToDate->letterGrade->comments;
        	
  } else {
  	$items['Sorry'] = 'The grades are not available to you.';
  }
  // $output = '';
  // foreach ($items as $k => $v) {
      // $output .= $k . ': ' . $v . '<br/>';
  // }
  
  // $output = '<h1>' . t('C plus plus for ' . $uid . ' from course ' . $cid) . '</h1>'; 
  
  if ($js) {
    ctools_include('ajax');
    $commands = array();
    $commands[] = ajax_command_html('#pearsongrade' . $uid . '-' . $cid, $html);
    print ajax_render($commands); // this function exits.
    exit;
  }
  else {
    return $output;
  }
}

function pearson_mp_node_view($node, $view_mode){
	// dsm($node, 'node');
	// dsm($view_mode, '$view_mode');
	if ($node->type == 'pearson_course'){
		// add the Announcement view to the bottom
		$view = '<hr/>';
		$annView = views_embed_view('pearson_announcements', 'page', $node->nid);
		if (strpos($annView, 'view-content')){
			// we have results
			$view .= '<h3>Announcement(s)</h3>' . $annView;
		} else{
			$view .= '<h3>No Announcements</h3>';
		}
		$node->content['viewAnn'] = array(
		 '#type' => 'markup',
		 '#weight' => 100,
		 '#markup' => $view,
		);						
	}
	return $node;
}

// returns an array like this: 0->entity_id, 1->entity_id

function classesByUID($uid){
	$query = db_select('users', 'u');
	$query->join('field_data_field_pearson_course_users', 'c', 'u.uid = c.field_pearson_course_users_target_id');
	$query	
		->fields('c', array('entity_id'))
		->condition('u.uid', $uid);
	$results = $query->execute()->fetchAll();
	return $results;
}
/*
	$findCourseID = $item->id;
	$query = db_select('node', 'n');
	$query->join('field_data_field_pearson_course_number', 'b', 'n.nid = b.entity_id');
	$query
	  ->fields('n', array('nid', 'vid'))
	  ->condition('n.type', 'pearson_course')
	  ->condition('b.field_pearson_course_number_value', $findCourseID);
	$result = $query->execute()->fetchAll();
	*/	


function subPearsonCourse(){
	$prin = variable_get('pearson_principal');
	$prin_shared = variable_get('pearson_principal_shared');
	$time = time();
	$tags = 'CourseID:8930875';
	$callbackURL = 'http://www.mikedotexe.com/pearson-ann/announcement';
	
	$StringParts = array('Timestamp' => $time, 'TAGS' => $tags, 'CALLBACK-URL' => $callbackURL); 
	ksort($StringParts); 
	 
	$encodable = array(); 	 
	foreach($StringParts as $key=>$value){ 
		$encodable[] = $key.'='.$value; 
	} 
	 
	$signable_string = urlencode(implode('&',$encodable)); 	 
	 
	// Get a Signature for the string. Signature is an AES-CMAC hash.
	$CMACEngine = new CryptLib\MAC\Implementation\CMAC;
	 
	$packed_string = ''; 
	$stringlength = strlen($signable_string); 
	for($i=0; $i<$stringlength; $i++) { 
	    $packed_string .= pack("c", ord(substr($signable_string, $i, 1))); 
	} 		
	// use Shared Secret to get CMAC
	$binary_cmac = $CMACEngine->generate($packed_string,$prin_shared); 
	
	$signature = base64_encode($binary_cmac);
	// add pipes
	$finalAuthorization = $prin . '|' . $time . '|' . $signature;
	
	$urlVars = array();
	$urlVars['TAGS'] = $tags;
	$urlVars['AUTHORIZATION'] = $finalAuthorization;
	$urlVars['CALLBACK-URL'] = $callbackURL;
	// CamelCase doesn't seem to matter
	// $urlVars['Tags'] = $tags;
	// $urlVars['Authorization'] = $finalAuthorization;
	// $urlVars['CallbackUrl'] = $callbackURL;
	
	ksort($urlVars);
	
	$encodable2= array(); 
	 
	foreach($urlVars as $key=>$value){ 
		$encodable2[] = $key.'='.$value; 
	} 	
	
	$urlVarsWebReady = urlencode(implode('&',$encodable2));
	
	$curl = curl_init();
	
	curl_setopt_array($curl, array(
	    CURLOPT_RETURNTRANSFER => 1,
	    CURLOPT_URL => 'https://prospero.ecollege.com/v1/subscription',
	    CURLOPT_POST => 1,
	    CURLOPT_POSTFIELDS => $urlVarsWebReady,
	    CURLOPT_HTTPHEADER => array('Content-Type: application/x-www-form-urlencoded'),
		CURLOPT_USERAGENT => 'Mozilla/5.0 (Windows; U; MSIE 9.0; WIndows NT 9.0; en-US)', 
	    CURLOPT_SSL_VERIFYPEER => 0,
	));
		 	
	// Execute & get variables
	$api_response = curl_exec($curl);
	$curlError = curl_error($curl);
	$info = curl_getinfo($curl); 
	$http_code = curl_getinfo($curl, CURLINFO_HTTP_CODE);
	curl_close($curl);	
	 
	// Test if there was a cURL problem (request didn't go through)
	if($curlError){
	 	 watchdog('pearson_mp', $curlError . " - There was a problem making the API Call. cURL problem in subPearsonCourse", NULL, WATCHDOG_CRITICAL);
		return 'Error: ' . $curlError;
	// Test if there is a 4XX error (request went through but erred). 
	} else if(intval($http_code / 100) >=4){
	 
		$decoded = json_decode($api_response); 
		$msg = (is_object($decoded) && isset($decoded->error->message))?$decoded->error->message:"No message reported.";
		$msg.= " Error ID: "; 
		$msg.= (is_object($decoded) && isset($decoded->error->errorId) && !empty($decoded->error->errorId))?$decoded->error->errorId:'None provided';  
	 	watchdog('pearson_mp', $msg . " - The API Server responded with ".$http_code.". Found in subPearsonCourse", NULL, WATCHDOG_CRITICAL);
		return 'Error: ' . $msg . ' ' . $http_code;
	} else {	 
		$decoded_response = json_decode($api_response); 
		// dsm($decoded_response);  
		return $decoded_response;
	}	
		
}

function _rule_announcement_update($node){
	dsm($node, 'node from rule');
}
